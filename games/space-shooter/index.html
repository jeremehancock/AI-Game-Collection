<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Space Game</title>
    <style>
		body {
			margin: 0;
			padding: 0;
			overflow: hidden;
			width: 100vw;
			height: 100vh;
			background: #000;
			font-family: Arial, sans-serif;
			display: flex;
			flex-direction: column;
			align-items: center;
		}

		#container {
			width: 100%;
			height: 100%;
			max-width: 700px;
			position: relative;
			display: flex;
			flex-direction: column;
			align-items: center;
			margin: 0 auto;
			background: #000;
		}

		canvas {
			display: block;
			background: #000;
			width: 100%;
			height: 100%;
			max-width: 700px;
		}

		#score {
			position: fixed;
			top: 20px;
			left: 50%;
			transform: translateX(-50%);
			margin-left: -315px;
			color: white;
			font-size: 24px;
			font-weight: bold;
			text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
			z-index: 10;
		}

		#start-screen {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			text-align: center;
			color: white;
			z-index: 20;
			width: 90%;
			max-width: 700px;
		}

		#controlArea {
			position: fixed;
			bottom: 90px;
			left: 50%;
			transform: translateX(-50%);
			width: 100%;
			max-width: 700px;
			height: 80px;
			background: rgba(51, 51, 51, 0.95);
			touch-action: pan-x;
			display: none;
			justify-content: center;
			align-items: center;
			-webkit-touch-callout: none;
			-webkit-user-select: none;
			user-select: none;
			z-index: 100;
		}

		.gesture-hint {
			position: absolute;
			left: 30%;
			transform: translateX(-20%);
			background: rgba(255, 255, 255, 0.2);
			padding: 8px 16px;
			border-radius: 20px;
			pointer-events: none;
			user-select: none;
			display: flex;
			align-items: center;
			gap: 10px;
			animation: fadeInOut 2s infinite;
			z-index: 10;
			color: white;
		}

		.mini-ship {
			width: 24px;
			height: 24px;
			position: relative;
			margin-left: 10px;
			animation: slideShip 2s infinite ease-in-out;
		}

		.mini-ship::before {
			content: '';
			position: absolute;
			top: 2px;
			left: 50%;
			transform: translateX(-50%);
			width: 12px;
			height: 20px;
			background: linear-gradient(90deg, #2c3e50, #34495e, #95a5a6, #34495e, #2c3e50);
			clip-path: polygon(50% 0%, 100% 100%, 0% 100%);
		}

		.mini-ship::after {
			content: '';
			position: absolute;
			top: 10px;
			left: 50%;
			transform: translateX(-50%);
			width: 24px;
			height: 12px;
			background: #34495e;
			clip-path: polygon(0 50%, 20% 100%, 80% 100%, 100% 50%, 80% 0, 20% 0);
		}

		.mini-ship .cockpit {
			position: absolute;
			top: 8px;
			left: 50%;
			transform: translateX(-50%);
			width: 6px;
			height: 8px;
			background: linear-gradient(180deg, rgba(52, 152, 219, 0.9), rgba(41, 128, 185, 0.7));
			border-radius: 3px;
			z-index: 1;
		}

		.mini-ship .engine {
			position: absolute;
			bottom: 0;
			left: 50%;
			transform: translateX(-50%);
			width: 6px;
			height: 4px;
			background: rgba(52, 152, 219, 0.6);
			border-radius: 0 0 3px 3px;
			animation: engineGlow 1s infinite alternate;
		}

		.game-overlay {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			width: 90%;
			max-width: 700px;
			height: 100%;
			background: rgba(0, 0, 0, 0.85);
			backdrop-filter: blur(5px);
			display: flex;
			justify-content: center;
			align-items: center;
			z-index: 1000;
		}

		.overlay-content {
			background: rgba(25, 25, 25, 0.9);
			border-radius: 15px;
			padding: 2rem;
			text-align: center;
			color: white;
			max-width: 90%;
			width: 400px;
			box-shadow: 0 0 40px rgba(0, 0, 0, 0.3);
			border: 1px solid rgba(255, 255, 255, 0.1);
		}

		.overlay-title {
			font-size: 3rem;
			margin: 0 0 1rem;
			background: linear-gradient(135deg, #3498db, #2ecc71);
			-webkit-background-clip: text;
			background-clip: text;
			color: transparent;
			text-shadow: none;
		}

		.game-over .overlay-title {
			background: linear-gradient(135deg, #e74c3c, #c0392b);
			-webkit-background-clip: text;
			background-clip: text;
		}

		.overlay-score {
			font-size: 1.5rem;
			margin: 1rem 0;
			color: #bdc3c7;
		}

		.overlay-button {
			padding: 0.8rem 2rem;
			font-size: 1.25rem;
			background: linear-gradient(135deg, #3498db, #2980b9);
			color: white;
			border: none;
			border-radius: 8px;
			cursor: pointer;
			transition: transform 0.2s, box-shadow 0.2s;
			margin: 1rem 0;
			text-transform: uppercase;
			letter-spacing: 1px;
			font-weight: bold;
		}

		.overlay-button:hover {
			transform: translateY(-2px);
			box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
		}

		.overlay-button:active {
			transform: translateY(0);
		}

		.overlay-instructions {
			margin: 1.5rem 0;
			color: #95a5a6;
			font-size: 1rem;
			line-height: 1.6;
		}

		.overlay-instructions p {
			margin: 0.5rem 0;
		}

		.control-icon {
			display: inline-block;
			padding: 0.2rem 0.5rem;
			background: rgba(255, 255, 255, 0.1);
			border-radius: 4px;
			margin: 0 0.2rem;
			font-family: monospace;
		}

		.mobile-instructions {
			display: none;
		}

		.desktop-instructions {
			display: block;
		}

		@keyframes engineGlow {
			from { opacity: 0.4; }
			to { opacity: 0.8; }
		}

		@keyframes slideShip {
			0%, 100% { transform: translateX(-15px); }
			50% { transform: translateX(15px); }
		}

		@keyframes fadeInOut {
			0% { opacity: 0.7; }
			50% { opacity: 1; }
			100% { opacity: 0.7; }
		}

		@media (max-width: 768px) {
			.mobile-instructions {
				display: block;
			}
			.desktop-instructions {
				display: none;
			}
			.overlay-content {
				padding: 1.5rem;
			}
			.overlay-title {
				font-size: 2.5rem;
			}
			.overlay-button {
				padding: 0.7rem 1.5rem;
				font-size: 1.1rem;
			}
			#score {
				left: 20px;
				transform: none;
				margin-left: 0;
			}
		}
    </style>
</head>
<body>
    <div id="container">
        <canvas id="gameCanvas"></canvas>
        <div id="score">Score: 0</div>
    </div>
    <div id="controlArea">
        <div class="gesture-hint">
            <div class="mini-ship">
                <div class="cockpit"></div>
                <div class="engine"></div>
            </div>
            <div class="swipe-icon"></div>
            <span class="swipe-text">Slide to move, Tap to shoot</span>
        </div>
    </div>
    <div id="start-screen" class="game-overlay">
        <div class="overlay-content">
            <h1 class="overlay-title">SPACE SHOOTER</h1>
            <button class="overlay-button">Start Game</button>
            <div class="overlay-instructions">
                <div class="desktop-instructions">
                    <p>Use <span class="control-icon">←</span> <span class="control-icon">→</span> to move</p>
                    <p>Press <span class="control-icon">SPACE</span> to shoot</p>
                </div>
            </div>
        </div>
    </div>

    <script>
		const canvas = document.getElementById('gameCanvas');
		const ctx = canvas.getContext('2d');
		const startScreen = document.getElementById('start-screen');
		const startButton = document.querySelector('.overlay-button');
		const scoreElement = document.getElementById('score');
		const controlArea = document.getElementById('controlArea');
		const gameWrapper = document.getElementById('game-wrapper');
		const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
		let gameStarted = false;
		let score = 0;
		let hasInteracted = false;

		// Audio Context setup
		let audioContext;
		let engineSound;
		let engineGainNode;

		// Audio initialization function
		async function initAudio() {
			audioContext = new (window.AudioContext || window.webkitAudioContext)();
			engineGainNode = audioContext.createGain();
			engineGainNode.gain.value = 0.1;
			engineGainNode.connect(audioContext.destination);
			
			engineSound = audioContext.createOscillator();
			engineSound.type = 'sine';
			engineSound.frequency.value = 100;
			engineSound.connect(engineGainNode);
			engineSound.start();
		}

		function playLaserSound() {
			if (!audioContext) return;
			
			const oscillator = audioContext.createOscillator();
			const gainNode = audioContext.createGain();
			
			oscillator.connect(gainNode);
			gainNode.connect(audioContext.destination);
			
			oscillator.type = 'square';
			oscillator.frequency.setValueAtTime(880, audioContext.currentTime);
			oscillator.frequency.exponentialRampToValueAtTime(110, audioContext.currentTime + 0.1);
			
			gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
			gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
			
			oscillator.start();
			oscillator.stop(audioContext.currentTime + 0.1);
		}

		function playExplosionSound() {
			if (!audioContext) return;
			
			const bufferSize = audioContext.sampleRate * 0.5;
			const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
			const data = buffer.getChannelData(0);
			
			for (let i = 0; i < bufferSize; i++) {
				const baseNoise = Math.random() * 2 - 1;
				const lowFreq = Math.sin(i * 0.01) * 0.5;
				data[i] = (baseNoise * 0.7 + lowFreq * 0.3) * (1 - i / bufferSize);
			}
			
			const source = audioContext.createBufferSource();
			const gainNode = audioContext.createGain();
			const lowPassFilter = audioContext.createBiquadFilter();
			
			lowPassFilter.type = 'lowpass';
			lowPassFilter.frequency.value = 1000;
			lowPassFilter.Q.value = 0.5;
			
			source.buffer = buffer;
			source.connect(lowPassFilter);
			lowPassFilter.connect(gainNode);
			gainNode.connect(audioContext.destination);
			
			gainNode.gain.setValueAtTime(0.8, audioContext.currentTime);
			gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.7);
			
			source.start();
		}

		function setCanvasSize() {
			const wrapper = gameWrapper.getBoundingClientRect();
			canvas.width = wrapper.width;
			canvas.height = isMobile ? window.innerHeight - 120 : window.innerHeight;
			
			if (gameStarted && typeof ship !== 'undefined') {
				ship.x = Math.min(ship.x, canvas.width - ship.size/2);
				ship.targetX = ship.x;
			}
		}

		setCanvasSize();

		window.addEventListener('resize', () => {
			setCanvasSize();
			if (gameStarted && typeof ship !== 'undefined') {
				ship.y = canvas.height - 100;
			}
		});

		const ship = {
			x: canvas.width / 2,
			y: canvas.height - 100,
			size: 40,
			targetX: canvas.width / 2
		};

		let asteroids = [];
		let bullets = [];
		let explosions = [];
		let lastShootTime = 0;
		const shootCooldown = 250;

		// Existing class definitions for Bullet, ExplosionParticle, and Asteroid remain the same

		function resetGestureHint() {
			const gestureHint = document.querySelector('.gesture-hint');
			if (gestureHint) {
				gestureHint.style.display = 'flex';
			}
			hasInteracted = false;
		}

		function shoot() {
			const now = Date.now();
			if (now - lastShootTime >= shootCooldown) {
				bullets.push(new Bullet(ship.x, ship.y - ship.size/2));
				lastShootTime = now;
				playLaserSound();
			}
		}

		function createExplosion(x, y) {
			for (let i = 0; i < 20; i++) {
				explosions.push(new ExplosionParticle(x, y));
			}
		}

		function checkCollision(asteroid) {
			const shipPoints = [
				{ x: ship.x, y: ship.y - ship.size/2 },
				{ x: ship.x + ship.size/2, y: ship.y + ship.size/2 },
				{ x: ship.x - ship.size/2, y: ship.y + ship.size/2 },
				{ x: ship.x, y: ship.y + ship.size/3 },
				{ x: ship.x, y: ship.y }
			];

			for (const point of shipPoints) {
				if (asteroid.isNearEdge(point.x, point.y)) {
				    return true;
				}
			}

			return false;
		}

		function checkBulletCollisions() {
			for (let i = bullets.length - 1; i >= 0; i--) {
				for (let j = asteroids.length - 1; j >= 0; j--) {
				    if (asteroids[j].isNearEdge(bullets[i].x, bullets[i].y)) {
				        createExplosion(asteroids[j].x, asteroids[j].y);
				        asteroids.splice(j, 1);
				        bullets.splice(i, 1);
				        score += 2;
				        scoreElement.textContent = `Score: ${score}`;
				        playExplosionSound();
				        break;
				    }
				}
			}
		}

		// Your existing drawShip function remains the same

		function updateShipPosition() {
			if (!isMobile) {
				const moveSpeed = 5;
				if (keys.left) ship.targetX -= moveSpeed;
				if (keys.right) ship.targetX += moveSpeed;
			}
			
			const deltaX = ship.targetX - ship.x;
			ship.x += deltaX * 0.3;
			ship.x = Math.max(ship.size/2, Math.min(canvas.width - ship.size/2, ship.x));
		}

		function updateGame() {
			if (!gameStarted) return;

			ctx.clearRect(0, 0, canvas.width, canvas.height);
			
			updateShipPosition();
			
			// Update and draw all game objects
			// ... rest of your updateGame function remains the same ...

			requestAnimationFrame(updateGame);
		}

		function gameOver() {
			gameStarted = false;
			
			if (engineGainNode) {
				engineGainNode.gain.setValueAtTime(engineGainNode.gain.value, audioContext.currentTime);
				engineGainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.5);
			}
			
			if (isMobile) {
				controlArea.style.display = 'none';
			}
			
			const overlay = document.createElement('div');
			overlay.className = 'game-overlay game-over';
			
			const content = document.createElement('div');
			content.className = 'overlay-content';
			
			// ... rest of your gameOver function remains the same ...
		}

		function startGame() {
			if (!audioContext) {
				initAudio();
			}
			gameStarted = true;
			score = 0;
			asteroids = [];
			bullets = [];
			explosions = [];
			scoreElement.textContent = 'Score: 0';
			startScreen.style.display = 'none';
			
			setCanvasSize();
			ship.x = canvas.width / 2;
			ship.y = canvas.height - 100;
			ship.targetX = ship.x;
			
			if (isMobile) {
				controlArea.style.display = 'flex';
				resetGestureHint();
			}
			
			requestAnimationFrame(updateGame);
		}

		// Touch handling
		let touchX = null;
		let touchStartTime = 0;
		let hasMoved = false;
		const TAP_THRESHOLD = 200;
		const MOVE_THRESHOLD = 10;

		// Add your existing touch event listeners here
		controlArea.addEventListener('touchstart', (e) => {
			e.preventDefault();
			if (!hasInteracted) {
				const gestureHint = document.querySelector('.gesture-hint');
				if (gestureHint) {
				    gestureHint.style.display = 'none';
				}
				hasInteracted = true;
			}
			const touch = e.touches[0];
			touchX = touch.clientX;
			touchStartTime = Date.now();
			hasMoved = false;
		});

		controlArea.addEventListener('touchmove', (e) => {
			e.preventDefault();
			if (!gameStarted || touchX === null) return;
			
			const touch = e.touches[0];
			const deltaX = touch.clientX - touchX;
			
			if (Math.abs(deltaX) > MOVE_THRESHOLD) {
				hasMoved = true;
			}
			
			ship.targetX = Math.max(ship.size/2, Math.min(canvas.width - ship.size/2, ship.x + deltaX));
			touchX = touch.clientX;
		});

		controlArea.addEventListener('touchend', (e) => {
			e.preventDefault();
			
			const touchDuration = Date.now() - touchStartTime;
			if (!hasMoved && touchDuration < TAP_THRESHOLD) {
				shoot();
			}
			
			touchX = null;
		});

		// Keyboard controls
		const keys = {
			left: false,
			right: false
		};

		document.addEventListener('keydown', (e) => {
			if (!gameStarted) return;
			switch(e.key) {
				case 'ArrowLeft':
				    keys.left = true;
				    e.preventDefault();
				    break;
				case 'ArrowRight':
				    keys.right = true;
				    e.preventDefault();
				    break;
				case ' ': // Spacebar
				    shoot();
				    e.preventDefault();
				    break;
			}
		});

		document.addEventListener('keyup', (e) => {
			if (!gameStarted) return;
			switch(e.key) {
				case 'ArrowLeft':
				    keys.left = false;
				    e.preventDefault();
				    break;
				case 'ArrowRight':
				    keys.right = false;
				    e.preventDefault();
				    break;
			}
		});

		document.addEventListener('DOMContentLoaded', () => {
			const startButton = document.querySelector('.overlay-button');
			startButton.addEventListener('click', startGame);
		});
			</script>
</body>
</html>
